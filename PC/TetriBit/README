===============================> README <===========================
==============================> TetriBit <==========================

          Curs : Programarea Calculatoarelor
          Grupa : 314CD
          Nume si Prenume : Grigore Lucian-Florin
          Tema 1 : TetriBit

Descrierea rezolvarii :

    Ceva ce nu a fost predat in primele cursuri sau laboratoare sunt Pointerii,
pe care i-am folosit in 3 functii ( cautareLinie, miscareDreapta si miscareStanga).
    Am considerat harta o variabila de tipul unsigned long long ,reprezentata
pe 64 de biti. De asemenea , piesele tot de tipul unsigned long long au fost
considerate. Functia main contine doar citirea lui n (harta propriu-zisa)
si M (numarul de piese care vor fi folosite) din fisierul de input. Din
main se apeleaza functia initializareJoc cu 2 parametri transmisi : harta
si numarul de piese. Din interiorul functiei initializareJoc se apeleaza
restul de 11 functii care ajuta la indeplinirea unor sarcini diferite:

    1. afisareHarta = afiseaza harta in timpul miscarii unei piese, la
    finalul jocului, dupa completarea unei linii etc. De asemenea, respecta
conventiile impuse in enuntul problemei : in loc de 1 afiseaza "#" , iar in loc de 0 afiseaza "."

    2. endGame = este functia de final de joc . Indeplineste task-uri precum:
afisarea hartii (daca este necesar), afiseaza mesajul de final: "GAME OVER!
Score:s", unde s este scorul calculat tot in cadrul functiei endGame, conform
formulei prezente in enunt

    3. cautareLinie = cauta pe harta o linie completa ( formata doar din 1 ) si
o sterge , apeland functia stergereLinie . De asemenea, incrementeaza variabila completedLines ( transmisa ca pointer )

    4. stergereLinie = sterge o linie de pe harta, folosind doua mask-uri
maskSus si maskJos. maskSus memoreaza ce este deasupra liniei care trebuie sterse , si este shiftata la dreapta cu 8 la final (coboara cu o linie). maskJos memoreaza ce este sub linia care trebuie stearsa. La final, harta primeste maskSus | maskJos.

    5. miscareJos = verifica daca piesa se poate misca in jos pe harta data.
Adica verifica daca piesa shiftata la dreapta cu 8 intra in coliziune cu harta.
Daca piesa nu se mai poate misca in jos, atunci intrerupe executia sirului de
miscari ale piesei curente

    6. miscareDreapta = misca piesa ( memoreaza doar jumatatea de jos a piesei
de 2 randuri) in dreapta , conform regulilor impuse : se opreste daca intra in coliziune cu harta, daca ajunge la marginea hartii, sau daca isi termina miscarea primita in fisierul de intrare. In cadrul acestei functii se apeleaza functia margineDreapta (descrisa mai jos). De asemenea, misca si copia sa, care memoreaza intreaga piesa ( daca este mai mare de un rand ).

    7. miscareStanga = misca piesa ( doar jumatatea de jos a piesei de 2
randuri ) in stanga, conform regulilor impuse: se opreste daca intra in coliziune cu harta, daca ajunge la marginea hartii, sau daca isi termina numarul de miscari primite in fisierul de intrare. In cadrul acestei functii se apeleaza functia margineStanga (descrisa mai jos). De asemenea, misca si copia sa , care memoreaza intreaga piesa ( in cazul in care piesa este mai mare de un rand )

    8. margineStanga = functia ce calculeaza distanta ramasa intre piesa si
marginea din stanga. Returneaza 1 daca piesa poate fi mutata in stanga si 0
daca ea deja se afla la margine

    9. margineDreapta = functia ce calculeaza distanta ramasa intre piesa si
marginea din dreapta. Returneaza 1 daca piesa poate fi mutata in dreapta si 0
daca ea deja se afla la margine

    10. miscareStangaSimpla = face aceleasi lucruri ca functia miscareStanga,
doar ca aceasta este folosita in cazul in care piesa ocupa doar un rand. Nu mai are vreo copie a piesei initiale, si nu foloseste vreun pointer

    11. miscareDreaptaSimpla = face aceleasi lucruri ca functie miscareDreapta,
doar ca aceasta este folosita in cazul in care piesa ocupa doar un rand. Nu mai are vreun pointer , sau vreo copie a piesei intiale


    Toate aceste functii sunt apelate in cadrul functiei initializareJoc, care
indeplineste mai multe sarcini:
    - citeste fiecare piesa in parte si cele 8 miscari aferente fiecareia,
contorizand de asemenea si numarul de linii complete (completedLines), necesar pentru calcularea scorului
    - sunt luate separat cazurile in care piesa ocupa mai mult de un rand, sau
doar un singur rand, la realizarea primelor miscari
    - la citirea unei piese , verifica daca aceasta incape pe harta. Daca nu ,
jocul se incheie , apelandu-se functia endGame. Daca incape pe harta, citeste
miscarile pe rand pana cand acestea se termina , sau nu mai pot fi realizate (piesa nu se mai poate deplasa in jos). Miscarile sunt citite in totalitate ( toate 8 ),dar sunt executate doar cele care sunt posibile
    - dupa terminarea secventei de miscare a piesei pe harta, se cauta liniile
complete , apeland functia cautareLinie
    - daca jocul nu se intrerupe altfel, el se termina in mod normal dupa citi-
rea tuturor pieselor
