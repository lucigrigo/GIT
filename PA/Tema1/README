                        Proiectarea Algoritmilor
                                 Tema 1
                       Grigore Lucian-Florin 324CD


                        Problema 1 - Temele buclucase

Aceasta problema este foarte asemanatoare cu cea a rucsacului, deci
programarea dinamica este cea mai potrivita. Aici trebuie sa tinem cont de doua
lucruri in construirea solutiei: elementul curent din parcurgerea temelor
si saptamana curenta. Astfel, este necesara o matrice de (numar_teme
* deadline_max) elemente de tip solutie. Recurenta din rezolvare se bazeaza
pe intrebarea "ce tema ar fi mai profitabil de facut intr-o anumita saptamana".
Rezolvarea incepe prin sortarea temelor crescator dupa deadline (am observat
ca nu este necesara si luarea in considerare a altor parametri, cum ar fi indexul
sau timpul de rezolvare).
Fie pasul i din rezolvare:
t=tema de la indicele i
cazuri de margine: - daca t->timp_rezolvare < sapt_curenta, atunci punem ce am re-
zolvat la pasul precedent, adica copiem ce este deasupra in margine
                - daca am depasit deadline-ul temei t, atunci punem in valoarea
corespunzatoarea saptamanii curenta maximul dintre ce am rezolvat la pasul prece-
dent sau ce am suprascris in saptamana trecuta.
Daca suntem in deadline-ul temei t, atunci consideram solutia optima prin ale-
gerea ori a organizarii temelor din pasul precedent (o linie mai sus in matrice),
ori a organizarii pana la sapt_curenta - t->timp_rezolvare, la care adaugam
profitul de pe urma rezolvarii temei curente.

Matricea noastra memoreaza "primele i teme care pot fi toate rezolvate cu deadline <= j"

Tehnica de programare folosita: Programare Dinamica
Complexitate: O(numar_teme * deadline_max)

                      Problema 2 - Numarul magic

Problema aceasta de fapt ascunde o alta abordare foarte eficienta, putand fi
considerata ca o problema care calculeaza distanta minima dintr-un plan intre doua puncte.
Putem face asta daca consideram ca fiecare element din vectorul de input poate
fi asezat intr-un plan dupa indexul din input (coordonata X) si suma pana la
acesta (coordonata Y). Apoi, aplicam recursiv o functie de calculare care cal-
culeaza minimul dintre doua zone obtinute prin impartirea la jumatate in raport
cu axa X (indicele din input). Apelul recursiv se opreste atunci cand sunt 3 sau
mai putin puncte intr-un subplan pentru a evita impartirea zonei cu un singur punct.
In acest moment, basically se face brute force pe aceste puncte, se memoreaza
distanta minima dintre acestea si indicii corespunzatori. In plus, se creeaza
un vector suplimentar Y care memoreaza punctele traversate ordonate, de aceasta
data, dupa suma (coordonata Y). La intoarcerea din recursivitate, minimul care
trebuie returnat este ori unul rezultat dintr-unul din apelurile recursive catre
zonele obtinute, ori un minim care se afla intre doua puncte, fiecare dintr-o
zona diferita. Pentru a afla acest minim de la granita, este necesara parcurgerea
unui vector Y local care este rezultat prin interclasarea vectorilor obtinuti de la
apelurile recursive si compararea elementelor care se afla la indeajuns de aproape
de jumatate la care a avut loc impartirea. Pentru fiecare element candidat, se
efectueaza un numar liniar de comparatii cu urmatoarele rate (maxim 7). Daca
se gaseste un nou minim, acesta va fi intors de functie. Aceasta interclasare
la intoarcerea din recursivitate ajuta complexitatea sa fie nlogn si nu nlog^2n.

Tehnica de programare folosita: Divide et Impera
Complexitate: O(n * log(n))

                      Problema 3 - Ratustele

Aceasta problema, chiar daca pare dificila la prima vedere, are cea mai usoara
rezolvare dintre toate. Partea cea mai dificila aici este interpretarea coliziunilor,
care poate fi facuta foarte eficient considerand o "ciocnire" ca fiind un schimb
de indici. Ratele initiale isi continua drumul, dar cand ies din apa, pot avea
un alt indice decat cel initial. Astfel, se poate trage urmatoarea concluzie:
numarul de rate care iese intr-o parte este egal cu numarul initial de rate care
se uita in acea parte. Practic, fiecare rata va avea la iesire indicele ultimei
rate cu care s-a intersectat. Deci, se poate folosi urmatorul rezultat:
Fie i_st numarul de rate care se uita in stanga de pe linia curenta si i_dp
numarul celor care se uita in dreapta. Parcurgand ratele de pe linie, indife-
rent de orientare, de la stanga la dreapta, primele i_st rate de pe linie
vor avea timpul de iesire egal cu cel al ratelor orientate la stanga, iar urma-
toarele rate vor avea timpul de iesire egal cu al celor orientate la dreapta.

Tehnica de programare folosita: Greedy (presupun, dar nu sunt sigur :) )
Complexitate: O(n)

                      Problema 4 - Jocul numerelor impare

Aceasta problema este intr-un fel asemanatoare cu prima deoarece necesita
construirea unei solutii optime, in functie de niste parametri. In loc de memorarea
tuturor solutiilor care se pot construi pana la un pas i, este necesara memorarea
solutiilor care indeplinesc anumite criterii pana la pasul i. Aceste criterii
sunt numarul de subsecvente, numarul de elemente din subsecvente si numarul de
elemente impare din acestea. Astfel, este necesara o structura pe 5 dimensiuni
pentru memorarea solutiilor.
Prima dimensiune: indicele (pasul rezolvarii) elementului curent din vector
Dim 2: numarul de subsecvente
Dim 3: numarul de elemente din subsecvente
Dim 4: paritatea numerelor impare din subsecventele create
Dim 5: alegerea, sau nu, a elementului curent

Astfel, la fiecare pas i al rezolvarii, se executa urmatorii pasi:
pentru fiecare numar de subsecvente posibil
pentru fiecare numar de elemente posibil
pentru fiecare tip de paritate
consideram doua cazuri:
daca alegem elementul curent, sau daca nu.
Daca nu il alegem, alegem solutia optima construita pana acum.
Daca il alegem, alegem maximul dintre toate combinatiile valide care se pot face
la pasul curent, tinand cont de modificarea valorilor si in functie de paritatea
curenta din structura comparativ la cea a elementului curent.

Tehnica de programare folosita: Programare Dinamica
Complexitate: O(n * k * l)
